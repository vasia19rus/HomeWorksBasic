# Домашка №1. Реализовать класс Matrix (матрица). Обеспечить перегрузку конструктора класса (метод __init__()),
# который должен принимать данные (список списков) для формирования матрицы. Подсказка: матрица — система некоторых
# математических величин, расположенных в виде прямоугольной схемы. Примеры матриц вы найдете в методичке. Следующий
# шаг — реализовать перегрузку метода __str__() для вывода матрицы в привычном виде. Далее реализовать перегрузку
# метода __add__() для реализации операции сложения двух объектов класса Matrix (двух матриц). Результатом сложения
# должна быть новая матрица. Подсказка: сложение элементов матриц выполнять поэлементно — первый элемент первой
# строки первой матрицы складываем с первым элементом первой строки второй матрицы и т.д.

from random import randint

a = []
for i in range(4):
    a.append([randint(10, 49), randint(10, 49), randint(10, 49), randint(10, 49)])
b = []
for i in range(4):
    b.append([randint(10, 49), randint(10, 49), randint(10, 49), randint(10, 49)])


class Matrix:

    def __init__(self, p_1, p_2, p_3, p_4):
        self.p_1 = p_1
        self.p_2 = p_2
        self.p_3 = p_3
        self.p_4 = p_4

    def __add__(self, other):
        return Matrix([x + y for x, y in zip(self.p_1, other.p_1)],
                      [x + y for x, y in zip(self.p_2, other.p_2)],
                      [x + y for x, y in zip(self.p_3, other.p_3)],
                      [x + y for x, y in zip(self.p_4, other.p_4)])

    def __str__(self):
        return f"{' '.join(map(str, self.p_1))}" \
               f"\n               {' '.join(map(str, self.p_2))}" \
               f"\n               {' '.join(map(str, self.p_3))}" \
               f"\n               {' '.join(map(str, self.p_4))}"


m = Matrix(a[0], a[1], a[2], a[3])
b = Matrix(b[0], b[1], b[2], b[3])
print("Первая матрица " + str(m))
print("Вторая матрица " + str(b))
print("Результат сложения\nдвух матриц    " + str(m + b))
